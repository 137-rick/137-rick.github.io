<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,maximum-scale=2">
  <link rel="stylesheet" type="text/css" media="screen" href="/assets/css/style.css?v=">

  <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>sphinx的实时索引 | 徐艺洲</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="sphinx的实时索引" />
<meta name="author" content="徐艺洲" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="sphinx目前出来一个realtime index即实时索引据官方透露，目前已经开始可以在生产环境使用他可以使用sphinxQL用mysql协议进行查询添加更新数据看起来像一个mysql一样，不过他支持全文检索，新更新进去的数据会自动索引达到实时索引的程度但是他也有缺点，比如经常更新会导致内存增长在内存中的数据如果不及时写入硬盘，出现中断会丢失数据只支持部分sql语句，前段时间简单测试了一下如果数据量巨大他会变得缓慢，在内存数据往硬盘写的时候会卡几秒下面是sphinx.conf内的一段关于实时索引的语句index rt{ # 实时索引类型 type = rt&lt;/p&gt; # 索引保存路径，平时都是保存在内存内，数据量超过内存量的时候会保存在文件内，这里随便存了下没放到data目录下 path = /usr/local/sphinx/var/data/rttest # 内存保存大小限制，超过这个就会保存到硬盘中 # optional, default is 32M，默认32m # rt_mem_limit = 32M # 全文检索字段声明，这里把实时索引的索引字段都声明出来 rt_field = title #全文索引字段 #rt_field = content rt_attr_uint = gid #其他属性字段，可以用来查询 rt_attr_bigint = guid #rt_attr_float = gpa #rt_attr_timestamp = ts_added #rt_attr_string = author}searchd{#这里配置很多只说关键的地方 listen = 9306:mysql41 #searchd支持mysql协议连接的端口max_matches = 3000 #在mysql协议内查询出来的数据只会返回3000条，即使使用limit语句也是如此} 启动searchd后shell下命令mysql -P 9306 -h 127.0.0.1连接sphinx 添加数据insert into rt values(3,&#8217;test&#8217;,1,2);注意，第一个字段必须指定值，因为id是sphinx内指定的唯一id 我用脚本添加了一批随机数据 下面可以用sql查询select * from rt order by id desc limit 1; +&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+|id | weight | gid | guid |+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+| 2613327| 1 | 179 | 45759 |+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+1 row in set (0.57 sec)如果不执行全文检索，那么性能和没有建立索引的mysql效果是一样其中weight是结果匹配权重 使用matchs在where内可以做全文检索大家可以参考官方文档，注意哦目前只有2.0.6才开始声明realtime index可以用于生产环境了2.0.6官方文档网址：http://sphinxsearch.com/docs/2.0.6/" />
<meta property="og:description" content="sphinx目前出来一个realtime index即实时索引据官方透露，目前已经开始可以在生产环境使用他可以使用sphinxQL用mysql协议进行查询添加更新数据看起来像一个mysql一样，不过他支持全文检索，新更新进去的数据会自动索引达到实时索引的程度但是他也有缺点，比如经常更新会导致内存增长在内存中的数据如果不及时写入硬盘，出现中断会丢失数据只支持部分sql语句，前段时间简单测试了一下如果数据量巨大他会变得缓慢，在内存数据往硬盘写的时候会卡几秒下面是sphinx.conf内的一段关于实时索引的语句index rt{ # 实时索引类型 type = rt&lt;/p&gt; # 索引保存路径，平时都是保存在内存内，数据量超过内存量的时候会保存在文件内，这里随便存了下没放到data目录下 path = /usr/local/sphinx/var/data/rttest # 内存保存大小限制，超过这个就会保存到硬盘中 # optional, default is 32M，默认32m # rt_mem_limit = 32M # 全文检索字段声明，这里把实时索引的索引字段都声明出来 rt_field = title #全文索引字段 #rt_field = content rt_attr_uint = gid #其他属性字段，可以用来查询 rt_attr_bigint = guid #rt_attr_float = gpa #rt_attr_timestamp = ts_added #rt_attr_string = author}searchd{#这里配置很多只说关键的地方 listen = 9306:mysql41 #searchd支持mysql协议连接的端口max_matches = 3000 #在mysql协议内查询出来的数据只会返回3000条，即使使用limit语句也是如此} 启动searchd后shell下命令mysql -P 9306 -h 127.0.0.1连接sphinx 添加数据insert into rt values(3,&#8217;test&#8217;,1,2);注意，第一个字段必须指定值，因为id是sphinx内指定的唯一id 我用脚本添加了一批随机数据 下面可以用sql查询select * from rt order by id desc limit 1; +&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+|id | weight | gid | guid |+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+| 2613327| 1 | 179 | 45759 |+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+1 row in set (0.57 sec)如果不执行全文检索，那么性能和没有建立索引的mysql效果是一样其中weight是结果匹配权重 使用matchs在where内可以做全文检索大家可以参考官方文档，注意哦目前只有2.0.6才开始声明realtime index可以用于生产环境了2.0.6官方文档网址：http://sphinxsearch.com/docs/2.0.6/" />
<link rel="canonical" href="http://localhost:4000/archives/154" />
<meta property="og:url" content="http://localhost:4000/archives/154" />
<meta property="og:site_name" content="徐艺洲" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-01-24T10:17:50+08:00" />
<script type="application/ld+json">
{"description":"sphinx目前出来一个realtime index即实时索引据官方透露，目前已经开始可以在生产环境使用他可以使用sphinxQL用mysql协议进行查询添加更新数据看起来像一个mysql一样，不过他支持全文检索，新更新进去的数据会自动索引达到实时索引的程度但是他也有缺点，比如经常更新会导致内存增长在内存中的数据如果不及时写入硬盘，出现中断会丢失数据只支持部分sql语句，前段时间简单测试了一下如果数据量巨大他会变得缓慢，在内存数据往硬盘写的时候会卡几秒下面是sphinx.conf内的一段关于实时索引的语句index rt{ # 实时索引类型 type = rt&lt;/p&gt; # 索引保存路径，平时都是保存在内存内，数据量超过内存量的时候会保存在文件内，这里随便存了下没放到data目录下 path = /usr/local/sphinx/var/data/rttest # 内存保存大小限制，超过这个就会保存到硬盘中 # optional, default is 32M，默认32m # rt_mem_limit = 32M # 全文检索字段声明，这里把实时索引的索引字段都声明出来 rt_field = title #全文索引字段 #rt_field = content rt_attr_uint = gid #其他属性字段，可以用来查询 rt_attr_bigint = guid #rt_attr_float = gpa #rt_attr_timestamp = ts_added #rt_attr_string = author}searchd{#这里配置很多只说关键的地方 listen = 9306:mysql41 #searchd支持mysql协议连接的端口max_matches = 3000 #在mysql协议内查询出来的数据只会返回3000条，即使使用limit语句也是如此} 启动searchd后shell下命令mysql -P 9306 -h 127.0.0.1连接sphinx 添加数据insert into rt values(3,&#8217;test&#8217;,1,2);注意，第一个字段必须指定值，因为id是sphinx内指定的唯一id 我用脚本添加了一批随机数据 下面可以用sql查询select * from rt order by id desc limit 1; +&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+|id | weight | gid | guid |+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+| 2613327| 1 | 179 | 45759 |+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+1 row in set (0.57 sec)如果不执行全文检索，那么性能和没有建立索引的mysql效果是一样其中weight是结果匹配权重 使用matchs在where内可以做全文检索大家可以参考官方文档，注意哦目前只有2.0.6才开始声明realtime index可以用于生产环境了2.0.6官方文档网址：http://sphinxsearch.com/docs/2.0.6/","headline":"sphinx的实时索引","dateModified":"2013-01-24T10:17:50+08:00","datePublished":"2013-01-24T10:17:50+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/archives/154"},"url":"http://localhost:4000/archives/154","author":{"@type":"Person","name":"徐艺洲"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body>

<!-- HEADER -->
<div id="header_wrap" class="outer">
  <header class="inner">
    

    <h1 id="project_title">徐艺洲</h1>
    <h2 id="project_tagline">知止定静安虑得</h2>
  </header>
</div>

<!-- MAIN CONTENT -->
<div id="main_content_wrap" class="outer">
  <section id="main_content" class="inner">
    <div id="sina_keyword_ad_area2" class="articalContent   ">
  sphinx目前出来一个realtime index即实时索引<br />据官方透露，目前已经开始可以在生产环境使用<br />他可以使用sphinxQL用mysql协议进行查询添加更新数据<br />看起来像一个mysql一样，不过他支持全文检索，新更新进去的数据会自动索引达到实时索引的程度<br />但是他也有缺点，比如经常更新会导致内存增长<br />在内存中的数据如果不及时写入硬盘，出现中断会丢失数据<br />只支持部分sql语句，前段时间简单测试了一下<br />如果数据量巨大他会变得缓慢，在内存数据往硬盘写的时候会卡几秒<br />下面是sphinx.conf内的一段关于实时索引的语句<br />index rt<br />{ <br /> # 实时索引类型<br /> type = rt&lt;/p&gt; 
  
  <p>
    # 索引保存路径，平时都是保存在内存内，数据量超过内存量的时候会保存在文件内，这里随便存了下没放到data目录下<br /> path = /usr/local/sphinx/var/data/rttest
  </p>
  
  <p>
    # 内存保存大小限制，超过这个就会保存到硬盘中<br /> # optional, default is 32M，默认32m<br /> #<br /> rt_mem_limit = 32M
  </p>
  
  <p>
    # 全文检索字段声明，这里把实时索引的索引字段都声明出来<br /> rt_field = title #全文索引字段<br /> #rt_field = content<br /> rt_attr_uint = gid #其他属性字段，可以用来查询<br /> rt_attr_bigint = guid<br /> #rt_attr_float = gpa<br /> #rt_attr_timestamp = ts_added<br /> #rt_attr_string = author<br />}<br />searchd<br />{<br />#这里配置很多只说关键的地方<br /> listen = 9306:mysql41 #searchd支持mysql协议连接的端口<br />max_matches = 3000 #在mysql协议内查询出来的数据只会返回3000条，即使使用limit语句也是如此<br />}
  </p>
  
  <p>
    启动searchd后<br />shell下命令<br />mysql -P 9306 -h 127.0.0.1<br />连接sphinx
  </p>
  
  <p>
    添加数据<br />insert into rt values(3,&#8217;test&#8217;,1,2);<br />注意，第一个字段必须指定值，因为id是sphinx内指定的唯一id
  </p>
  
  <p>
    我用脚本添加了一批随机数据
  </p>
  
  <p>
    下面可以用sql查询<br />select * from rt order by id desc limit 1;
  </p>
  
  <p>
    +&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+<br />|id | weight | gid | guid |<br />+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+<br />| 2613327| 1 | 179 | 45759 |<br />+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+<br />1 row in set (0.57 sec)<br />如果不执行全文检索，那么性能和没有建立索引的mysql效果是一样<br />其中weight是结果匹配权重
  </p>
  
  <p>
    使用matchs在where内可以做全文检索<br />大家可以参考官方文档，注意哦目前只有2.0.6才开始声明realtime index可以用于生产环境了<br />2.0.6官方文档网址：<br />http://sphinxsearch.com/docs/2.0.6/
  </p>
</div>

  </section>
</div>

<!-- FOOTER  -->
<div id="footer_wrap" class="outer">
  <footer class="inner">
    
    <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
  </footer>
</div>


</body>
</html>
