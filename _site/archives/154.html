<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>sphinx的实时索引 | Your awesome title</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="sphinx的实时索引" />
<meta name="author" content="徐艺洲" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="sphinx目前出来一个realtime index即实时索引据官方透露，目前已经开始可以在生产环境使用他可以使用sphinxQL用mysql协议进行查询添加更新数据看起来像一个mysql一样，不过他支持全文检索，新更新进去的数据会自动索引达到实时索引的程度但是他也有缺点，比如经常更新会导致内存增长在内存中的数据如果不及时写入硬盘，出现中断会丢失数据只支持部分sql语句，前段时间简单测试了一下如果数据量巨大他会变得缓慢，在内存数据往硬盘写的时候会卡几秒下面是sphinx.conf内的一段关于实时索引的语句index rt{ # 实时索引类型 type = rt&lt;/p&gt; # 索引保存路径，平时都是保存在内存内，数据量超过内存量的时候会保存在文件内，这里随便存了下没放到data目录下 path = /usr/local/sphinx/var/data/rttest # 内存保存大小限制，超过这个就会保存到硬盘中 # optional, default is 32M，默认32m # rt_mem_limit = 32M # 全文检索字段声明，这里把实时索引的索引字段都声明出来 rt_field = title #全文索引字段 #rt_field = content rt_attr_uint = gid #其他属性字段，可以用来查询 rt_attr_bigint = guid #rt_attr_float = gpa #rt_attr_timestamp = ts_added #rt_attr_string = author}searchd{#这里配置很多只说关键的地方 listen = 9306:mysql41 #searchd支持mysql协议连接的端口max_matches = 3000 #在mysql协议内查询出来的数据只会返回3000条，即使使用limit语句也是如此} 启动searchd后shell下命令mysql -P 9306 -h 127.0.0.1连接sphinx 添加数据insert into rt values(3,&#8217;test&#8217;,1,2);注意，第一个字段必须指定值，因为id是sphinx内指定的唯一id 我用脚本添加了一批随机数据 下面可以用sql查询select * from rt order by id desc limit 1; +&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+|id | weight | gid | guid |+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+| 2613327| 1 | 179 | 45759 |+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+1 row in set (0.57 sec)如果不执行全文检索，那么性能和没有建立索引的mysql效果是一样其中weight是结果匹配权重 使用matchs在where内可以做全文检索大家可以参考官方文档，注意哦目前只有2.0.6才开始声明realtime index可以用于生产环境了2.0.6官方文档网址：http://sphinxsearch.com/docs/2.0.6/" />
<meta property="og:description" content="sphinx目前出来一个realtime index即实时索引据官方透露，目前已经开始可以在生产环境使用他可以使用sphinxQL用mysql协议进行查询添加更新数据看起来像一个mysql一样，不过他支持全文检索，新更新进去的数据会自动索引达到实时索引的程度但是他也有缺点，比如经常更新会导致内存增长在内存中的数据如果不及时写入硬盘，出现中断会丢失数据只支持部分sql语句，前段时间简单测试了一下如果数据量巨大他会变得缓慢，在内存数据往硬盘写的时候会卡几秒下面是sphinx.conf内的一段关于实时索引的语句index rt{ # 实时索引类型 type = rt&lt;/p&gt; # 索引保存路径，平时都是保存在内存内，数据量超过内存量的时候会保存在文件内，这里随便存了下没放到data目录下 path = /usr/local/sphinx/var/data/rttest # 内存保存大小限制，超过这个就会保存到硬盘中 # optional, default is 32M，默认32m # rt_mem_limit = 32M # 全文检索字段声明，这里把实时索引的索引字段都声明出来 rt_field = title #全文索引字段 #rt_field = content rt_attr_uint = gid #其他属性字段，可以用来查询 rt_attr_bigint = guid #rt_attr_float = gpa #rt_attr_timestamp = ts_added #rt_attr_string = author}searchd{#这里配置很多只说关键的地方 listen = 9306:mysql41 #searchd支持mysql协议连接的端口max_matches = 3000 #在mysql协议内查询出来的数据只会返回3000条，即使使用limit语句也是如此} 启动searchd后shell下命令mysql -P 9306 -h 127.0.0.1连接sphinx 添加数据insert into rt values(3,&#8217;test&#8217;,1,2);注意，第一个字段必须指定值，因为id是sphinx内指定的唯一id 我用脚本添加了一批随机数据 下面可以用sql查询select * from rt order by id desc limit 1; +&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+|id | weight | gid | guid |+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+| 2613327| 1 | 179 | 45759 |+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+1 row in set (0.57 sec)如果不执行全文检索，那么性能和没有建立索引的mysql效果是一样其中weight是结果匹配权重 使用matchs在where内可以做全文检索大家可以参考官方文档，注意哦目前只有2.0.6才开始声明realtime index可以用于生产环境了2.0.6官方文档网址：http://sphinxsearch.com/docs/2.0.6/" />
<link rel="canonical" href="http://localhost:4000/archives/154" />
<meta property="og:url" content="http://localhost:4000/archives/154" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-01-24T10:17:50+08:00" />
<script type="application/ld+json">
{"description":"sphinx目前出来一个realtime index即实时索引据官方透露，目前已经开始可以在生产环境使用他可以使用sphinxQL用mysql协议进行查询添加更新数据看起来像一个mysql一样，不过他支持全文检索，新更新进去的数据会自动索引达到实时索引的程度但是他也有缺点，比如经常更新会导致内存增长在内存中的数据如果不及时写入硬盘，出现中断会丢失数据只支持部分sql语句，前段时间简单测试了一下如果数据量巨大他会变得缓慢，在内存数据往硬盘写的时候会卡几秒下面是sphinx.conf内的一段关于实时索引的语句index rt{ # 实时索引类型 type = rt&lt;/p&gt; # 索引保存路径，平时都是保存在内存内，数据量超过内存量的时候会保存在文件内，这里随便存了下没放到data目录下 path = /usr/local/sphinx/var/data/rttest # 内存保存大小限制，超过这个就会保存到硬盘中 # optional, default is 32M，默认32m # rt_mem_limit = 32M # 全文检索字段声明，这里把实时索引的索引字段都声明出来 rt_field = title #全文索引字段 #rt_field = content rt_attr_uint = gid #其他属性字段，可以用来查询 rt_attr_bigint = guid #rt_attr_float = gpa #rt_attr_timestamp = ts_added #rt_attr_string = author}searchd{#这里配置很多只说关键的地方 listen = 9306:mysql41 #searchd支持mysql协议连接的端口max_matches = 3000 #在mysql协议内查询出来的数据只会返回3000条，即使使用limit语句也是如此} 启动searchd后shell下命令mysql -P 9306 -h 127.0.0.1连接sphinx 添加数据insert into rt values(3,&#8217;test&#8217;,1,2);注意，第一个字段必须指定值，因为id是sphinx内指定的唯一id 我用脚本添加了一批随机数据 下面可以用sql查询select * from rt order by id desc limit 1; +&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+|id | weight | gid | guid |+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+| 2613327| 1 | 179 | 45759 |+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+1 row in set (0.57 sec)如果不执行全文检索，那么性能和没有建立索引的mysql效果是一样其中weight是结果匹配权重 使用matchs在where内可以做全文检索大家可以参考官方文档，注意哦目前只有2.0.6才开始声明realtime index可以用于生产环境了2.0.6官方文档网址：http://sphinxsearch.com/docs/2.0.6/","headline":"sphinx的实时索引","dateModified":"2013-01-24T10:17:50+08:00","datePublished":"2013-01-24T10:17:50+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/archives/154"},"url":"http://localhost:4000/archives/154","author":{"@type":"Person","name":"徐艺洲"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Your awesome title" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Your awesome title</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/%25e5%2585%25b3%25e4%25ba%258e%25e6%259c%25ac%25e4%25ba%25ba.html">关于本人</a><a class="page-link" href="/%25e5%2585%25b3%25e4%25ba%258e%25e8%2593%259d%25e5%25a4%25a9.html">关于我</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">sphinx的实时索引</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2013-01-24T10:17:50+08:00" itemprop="datePublished">Jan 24, 2013
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">徐艺洲</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div id="sina_keyword_ad_area2" class="articalContent   ">
  sphinx目前出来一个realtime index即实时索引<br />据官方透露，目前已经开始可以在生产环境使用<br />他可以使用sphinxQL用mysql协议进行查询添加更新数据<br />看起来像一个mysql一样，不过他支持全文检索，新更新进去的数据会自动索引达到实时索引的程度<br />但是他也有缺点，比如经常更新会导致内存增长<br />在内存中的数据如果不及时写入硬盘，出现中断会丢失数据<br />只支持部分sql语句，前段时间简单测试了一下<br />如果数据量巨大他会变得缓慢，在内存数据往硬盘写的时候会卡几秒<br />下面是sphinx.conf内的一段关于实时索引的语句<br />index rt<br />{ <br /> # 实时索引类型<br /> type = rt&lt;/p&gt; 
  
  <p>
    # 索引保存路径，平时都是保存在内存内，数据量超过内存量的时候会保存在文件内，这里随便存了下没放到data目录下<br /> path = /usr/local/sphinx/var/data/rttest
  </p>
  
  <p>
    # 内存保存大小限制，超过这个就会保存到硬盘中<br /> # optional, default is 32M，默认32m<br /> #<br /> rt_mem_limit = 32M
  </p>
  
  <p>
    # 全文检索字段声明，这里把实时索引的索引字段都声明出来<br /> rt_field = title #全文索引字段<br /> #rt_field = content<br /> rt_attr_uint = gid #其他属性字段，可以用来查询<br /> rt_attr_bigint = guid<br /> #rt_attr_float = gpa<br /> #rt_attr_timestamp = ts_added<br /> #rt_attr_string = author<br />}<br />searchd<br />{<br />#这里配置很多只说关键的地方<br /> listen = 9306:mysql41 #searchd支持mysql协议连接的端口<br />max_matches = 3000 #在mysql协议内查询出来的数据只会返回3000条，即使使用limit语句也是如此<br />}
  </p>
  
  <p>
    启动searchd后<br />shell下命令<br />mysql -P 9306 -h 127.0.0.1<br />连接sphinx
  </p>
  
  <p>
    添加数据<br />insert into rt values(3,&#8217;test&#8217;,1,2);<br />注意，第一个字段必须指定值，因为id是sphinx内指定的唯一id
  </p>
  
  <p>
    我用脚本添加了一批随机数据
  </p>
  
  <p>
    下面可以用sql查询<br />select * from rt order by id desc limit 1;
  </p>
  
  <p>
    +&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+<br />|id | weight | gid | guid |<br />+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+<br />| 2613327| 1 | 179 | 45759 |<br />+&#8212;&#8212;&#8212;+&#8212;&#8212;&#8211;+&#8212;&#8212;+&#8212;&#8212;-+<br />1 row in set (0.57 sec)<br />如果不执行全文检索，那么性能和没有建立索引的mysql效果是一样<br />其中weight是结果匹配权重
  </p>
  
  <p>
    使用matchs在where内可以做全文检索<br />大家可以参考官方文档，注意哦目前只有2.0.6才开始声明realtime index可以用于生产环境了<br />2.0.6官方文档网址：<br />http://sphinxsearch.com/docs/2.0.6/
  </p>
</div>

  </div><a class="u-url" href="/archives/154" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Your awesome title</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
