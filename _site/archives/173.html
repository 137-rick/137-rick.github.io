<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>【翻译整理】mysql innodb 的开发细节注意事项 | 徐艺洲</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="【翻译整理】mysql innodb 的开发细节注意事项" />
<meta name="author" content="徐艺洲" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="&#8212;资料整理线&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&lt;/p&gt; ************常规通用知识***************innodb不支持全文索引count（*）会扫表，变慢了auto increament必须只有一个作为主键innodb delete from table很慢，因为是一条条删除innodb行锁是基与索引进行锁定的，如果要搞行锁的一定要注意不要在innodb内做主键值更新innodb 偏 insert update ，myiasm偏查询innodb 多条update建议启用事务，否则容易卡慢超时如果将自动提交关闭（SETAUTOCOMMIT= 0），那么innodb的性能会有显著提高，但是开发过程中需要底层驱动自动执行提交事务操作否则对数据的更改添加的数据就会丢失事务会超时，底层一定要做好捕获 ********表的设计*******innodb的主键是和数据一起存储的，所以当设计主键的时候可以考虑使用组合主键可以使得相同前缀的数据在一起主键的无序随机存储会导致系统开销特别大，尽量通过主键排序，读取数据的时候尽量按照主键顺序读取会更快，如果主键是auto incresement不要更新主键开销特别大主键要尽量的短因为其他索引是使用这个主键做索引的，这个会关系到索引的大小，如果索引过大，会导致查询缓慢 没有主键的表查询会慢很多，但是这种情况他内部会创建 一个key ，不过查询的时候不好使用如果一个表中有主键，同时所有查询都是通过主键进行，即使主键是比较长的，那通过主键进行查询也是更快的。你可以给主键设置autoincreament并且加入唯一索引 一个库内不要有太多的表InnoDB自己的表定义（字典）缓存依赖于MySQL的table_cache变量值。只要打开一次，InnoDB就不会从缓存中移除这个表。每张表大概要消耗4KB以上的空间。MySQL 5.1 的 InnoDB已经将这个空间减少了50% 到 75%，当重启时，每个表的统计将会被重新计算。所以启动会是非常耗资源的。使用MySQL的插件table_cache将会串行执行这些操作。 *********索引**********使用唯一索引作为索引，查询速度会快很多innodb的索引会比myiasm大很多，所以创建索引的时候要注意索引的大小，如果过大可能效果反倒不如没有索引避免过多的索引对所有需要更新时查询的列进行索引，如 DELETE FROM users WHEREname=’peter’如果name没有索引会锁定整个表不要给自动增长字段设置值，否则在insert的时候会锁表，导致并发为1 ********关于锁*********当insert执行的时候拥有autoincrement（不在事务内）有几率锁表，会导致并发插入数据的时候的性能下降（这个问题据说在修5.5以后应该修了）普通select不会锁表只对需要的行进行锁定才会获得更好的性能，如果不能规划好解决事务间锁定冲突问题尽量不要使用锁，否则会导致卡住直到超时共享锁的时候当产生更新到锁定数据的时候会禁止其他读锁访问缓慢的select查询，不会影响表的update和查询操作慢查询尽量避免，他会影响到数据一致性，如果使用 事务隔离级别read committed效果会好很多 在readcommited模式下select会锁定。因为不能lock一个不存在的行。这个查询结果会跟普通的select是不同的。SELECT…FOR UPDATE总是不得不访问行数据进行lock，所以这种情况下索引是不会生效的，这样事务会很慢 select没有锁的字段是不会执行锁定的务必控制好锁定的时间，如果事务执行时间很长，会对系统有很大问题锁定需要的数据，无关的不要锁定缩减一个事务的处理粒度对整个表的影响（更改添加）越小越好使用SELECT…FOR UPDATE如果你想更新大部分你所选择的行外部锁sELECT GET_LOCK(‘mylock’)可以避免死锁 *********隔离级别********nnoDB支持很多种的隔离级别。这些隔离级别可以设置为全局有效 也可以针对每个连接和每个事务。 READ UMCOMMITED（不提交读）— 这个是很少使用。其他事务未提交的数据也可以读取到，会影响性能。 READCOMMITED（获取提交的数据）在执行过程中，可以读取到其他事务刚提交（commit）完毕的数据。在mysql5.1，InnoDB会有一些间歇锁在这个级别上。使用行级复制 和binlog可以避免这个问题。 REPEATABLE READ（可重复读）—默认的隔离级别。事务内的读都是完全可重复的，即事务只读取事务开始时候的数据状态，正在事务执行的时产生的数据不会出现。 SERIALIZABLE（串行化）&ndash;让所有select都锁住select，尽可能避免使用这个隔离级别。他会导致整个表只有一个select在执行，其他排队 ***********外键***********行更新的时候会检查外键，对性能有影响，现在很少人使用它了外键的更新会行锁定自己相关数据及其他表相关数据外键会锁住子表，当父表在更新的时候。（select … for update在父表上这样执行就不会锁住子表 ***********事务**********************在一定数量内的运行中的事务和执行查询，InnoDB性能表现良好多个运行中查询如果出现相互的性能干扰。通过配置Innodb_thread_concurrency能够控制同事在InnoDB内核中执行查询的线程数量。过多的事务运行会导致表内大量的锁，建议尽量减少锁在事务中的使用如果有可能，在同一时间内限制一定数量的查询，在应用程序端做好队列，这样能缓解服务器压力。处理量过多事务会超时回滚，在你调用的时候驱动要能够捕获这个错误 **********insert by select *****执行这个操作会导致select查询排队锁定直到他执行完毕强烈建议使用select into outfile或者load data infile不要直接这么查询 ***********间隙锁*************行锁的时候不仅仅锁定相关数据行，还会锁定两个行锁之间的数据，因为使用REPEATABLEREAD隔离模式的时候会出现重复数据。如果没有使用binlog，那么可以禁止这个间隙锁 *********关于count（*）*****innodb和myiasm如果count的时候有where条件的时候速度是一样的，如果没有条件那么myiasm速度最快innodb引擎变量内有一个表内数据总个数，但是这个数值不准innodb尽量避免使用大量数据的count*查询或者全表 *********推荐开发参考必看的经典***************http://7567567.blog.51cto.com/706378/586925 这个是下面的翻译，有很多不准确的地方，上面的介绍是我根据下面的的ppt再修正的http://www.mysqlperformanceblog.com/files/presentations/UC2007-Innodb-Performance-Optimization.pdf **********系统配置方面优化好文********************推荐文章地址：http://imysql.cn/node/609这个介绍的不错，讲了很多配置细节可以参考这个做数据库配置优化,并且有很多优化细节系列文章介绍" />
<meta property="og:description" content="&#8212;资料整理线&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&lt;/p&gt; ************常规通用知识***************innodb不支持全文索引count（*）会扫表，变慢了auto increament必须只有一个作为主键innodb delete from table很慢，因为是一条条删除innodb行锁是基与索引进行锁定的，如果要搞行锁的一定要注意不要在innodb内做主键值更新innodb 偏 insert update ，myiasm偏查询innodb 多条update建议启用事务，否则容易卡慢超时如果将自动提交关闭（SETAUTOCOMMIT= 0），那么innodb的性能会有显著提高，但是开发过程中需要底层驱动自动执行提交事务操作否则对数据的更改添加的数据就会丢失事务会超时，底层一定要做好捕获 ********表的设计*******innodb的主键是和数据一起存储的，所以当设计主键的时候可以考虑使用组合主键可以使得相同前缀的数据在一起主键的无序随机存储会导致系统开销特别大，尽量通过主键排序，读取数据的时候尽量按照主键顺序读取会更快，如果主键是auto incresement不要更新主键开销特别大主键要尽量的短因为其他索引是使用这个主键做索引的，这个会关系到索引的大小，如果索引过大，会导致查询缓慢 没有主键的表查询会慢很多，但是这种情况他内部会创建 一个key ，不过查询的时候不好使用如果一个表中有主键，同时所有查询都是通过主键进行，即使主键是比较长的，那通过主键进行查询也是更快的。你可以给主键设置autoincreament并且加入唯一索引 一个库内不要有太多的表InnoDB自己的表定义（字典）缓存依赖于MySQL的table_cache变量值。只要打开一次，InnoDB就不会从缓存中移除这个表。每张表大概要消耗4KB以上的空间。MySQL 5.1 的 InnoDB已经将这个空间减少了50% 到 75%，当重启时，每个表的统计将会被重新计算。所以启动会是非常耗资源的。使用MySQL的插件table_cache将会串行执行这些操作。 *********索引**********使用唯一索引作为索引，查询速度会快很多innodb的索引会比myiasm大很多，所以创建索引的时候要注意索引的大小，如果过大可能效果反倒不如没有索引避免过多的索引对所有需要更新时查询的列进行索引，如 DELETE FROM users WHEREname=’peter’如果name没有索引会锁定整个表不要给自动增长字段设置值，否则在insert的时候会锁表，导致并发为1 ********关于锁*********当insert执行的时候拥有autoincrement（不在事务内）有几率锁表，会导致并发插入数据的时候的性能下降（这个问题据说在修5.5以后应该修了）普通select不会锁表只对需要的行进行锁定才会获得更好的性能，如果不能规划好解决事务间锁定冲突问题尽量不要使用锁，否则会导致卡住直到超时共享锁的时候当产生更新到锁定数据的时候会禁止其他读锁访问缓慢的select查询，不会影响表的update和查询操作慢查询尽量避免，他会影响到数据一致性，如果使用 事务隔离级别read committed效果会好很多 在readcommited模式下select会锁定。因为不能lock一个不存在的行。这个查询结果会跟普通的select是不同的。SELECT…FOR UPDATE总是不得不访问行数据进行lock，所以这种情况下索引是不会生效的，这样事务会很慢 select没有锁的字段是不会执行锁定的务必控制好锁定的时间，如果事务执行时间很长，会对系统有很大问题锁定需要的数据，无关的不要锁定缩减一个事务的处理粒度对整个表的影响（更改添加）越小越好使用SELECT…FOR UPDATE如果你想更新大部分你所选择的行外部锁sELECT GET_LOCK(‘mylock’)可以避免死锁 *********隔离级别********nnoDB支持很多种的隔离级别。这些隔离级别可以设置为全局有效 也可以针对每个连接和每个事务。 READ UMCOMMITED（不提交读）— 这个是很少使用。其他事务未提交的数据也可以读取到，会影响性能。 READCOMMITED（获取提交的数据）在执行过程中，可以读取到其他事务刚提交（commit）完毕的数据。在mysql5.1，InnoDB会有一些间歇锁在这个级别上。使用行级复制 和binlog可以避免这个问题。 REPEATABLE READ（可重复读）—默认的隔离级别。事务内的读都是完全可重复的，即事务只读取事务开始时候的数据状态，正在事务执行的时产生的数据不会出现。 SERIALIZABLE（串行化）&ndash;让所有select都锁住select，尽可能避免使用这个隔离级别。他会导致整个表只有一个select在执行，其他排队 ***********外键***********行更新的时候会检查外键，对性能有影响，现在很少人使用它了外键的更新会行锁定自己相关数据及其他表相关数据外键会锁住子表，当父表在更新的时候。（select … for update在父表上这样执行就不会锁住子表 ***********事务**********************在一定数量内的运行中的事务和执行查询，InnoDB性能表现良好多个运行中查询如果出现相互的性能干扰。通过配置Innodb_thread_concurrency能够控制同事在InnoDB内核中执行查询的线程数量。过多的事务运行会导致表内大量的锁，建议尽量减少锁在事务中的使用如果有可能，在同一时间内限制一定数量的查询，在应用程序端做好队列，这样能缓解服务器压力。处理量过多事务会超时回滚，在你调用的时候驱动要能够捕获这个错误 **********insert by select *****执行这个操作会导致select查询排队锁定直到他执行完毕强烈建议使用select into outfile或者load data infile不要直接这么查询 ***********间隙锁*************行锁的时候不仅仅锁定相关数据行，还会锁定两个行锁之间的数据，因为使用REPEATABLEREAD隔离模式的时候会出现重复数据。如果没有使用binlog，那么可以禁止这个间隙锁 *********关于count（*）*****innodb和myiasm如果count的时候有where条件的时候速度是一样的，如果没有条件那么myiasm速度最快innodb引擎变量内有一个表内数据总个数，但是这个数值不准innodb尽量避免使用大量数据的count*查询或者全表 *********推荐开发参考必看的经典***************http://7567567.blog.51cto.com/706378/586925 这个是下面的翻译，有很多不准确的地方，上面的介绍是我根据下面的的ppt再修正的http://www.mysqlperformanceblog.com/files/presentations/UC2007-Innodb-Performance-Optimization.pdf **********系统配置方面优化好文********************推荐文章地址：http://imysql.cn/node/609这个介绍的不错，讲了很多配置细节可以参考这个做数据库配置优化,并且有很多优化细节系列文章介绍" />
<link rel="canonical" href="http://localhost:4000/archives/173" />
<meta property="og:url" content="http://localhost:4000/archives/173" />
<meta property="og:site_name" content="徐艺洲" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-03-06T11:38:10+08:00" />
<script type="application/ld+json">
{"description":"&#8212;资料整理线&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&lt;/p&gt; ************常规通用知识***************innodb不支持全文索引count（*）会扫表，变慢了auto increament必须只有一个作为主键innodb delete from table很慢，因为是一条条删除innodb行锁是基与索引进行锁定的，如果要搞行锁的一定要注意不要在innodb内做主键值更新innodb 偏 insert update ，myiasm偏查询innodb 多条update建议启用事务，否则容易卡慢超时如果将自动提交关闭（SETAUTOCOMMIT= 0），那么innodb的性能会有显著提高，但是开发过程中需要底层驱动自动执行提交事务操作否则对数据的更改添加的数据就会丢失事务会超时，底层一定要做好捕获 ********表的设计*******innodb的主键是和数据一起存储的，所以当设计主键的时候可以考虑使用组合主键可以使得相同前缀的数据在一起主键的无序随机存储会导致系统开销特别大，尽量通过主键排序，读取数据的时候尽量按照主键顺序读取会更快，如果主键是auto incresement不要更新主键开销特别大主键要尽量的短因为其他索引是使用这个主键做索引的，这个会关系到索引的大小，如果索引过大，会导致查询缓慢 没有主键的表查询会慢很多，但是这种情况他内部会创建 一个key ，不过查询的时候不好使用如果一个表中有主键，同时所有查询都是通过主键进行，即使主键是比较长的，那通过主键进行查询也是更快的。你可以给主键设置autoincreament并且加入唯一索引 一个库内不要有太多的表InnoDB自己的表定义（字典）缓存依赖于MySQL的table_cache变量值。只要打开一次，InnoDB就不会从缓存中移除这个表。每张表大概要消耗4KB以上的空间。MySQL 5.1 的 InnoDB已经将这个空间减少了50% 到 75%，当重启时，每个表的统计将会被重新计算。所以启动会是非常耗资源的。使用MySQL的插件table_cache将会串行执行这些操作。 *********索引**********使用唯一索引作为索引，查询速度会快很多innodb的索引会比myiasm大很多，所以创建索引的时候要注意索引的大小，如果过大可能效果反倒不如没有索引避免过多的索引对所有需要更新时查询的列进行索引，如 DELETE FROM users WHEREname=’peter’如果name没有索引会锁定整个表不要给自动增长字段设置值，否则在insert的时候会锁表，导致并发为1 ********关于锁*********当insert执行的时候拥有autoincrement（不在事务内）有几率锁表，会导致并发插入数据的时候的性能下降（这个问题据说在修5.5以后应该修了）普通select不会锁表只对需要的行进行锁定才会获得更好的性能，如果不能规划好解决事务间锁定冲突问题尽量不要使用锁，否则会导致卡住直到超时共享锁的时候当产生更新到锁定数据的时候会禁止其他读锁访问缓慢的select查询，不会影响表的update和查询操作慢查询尽量避免，他会影响到数据一致性，如果使用 事务隔离级别read committed效果会好很多 在readcommited模式下select会锁定。因为不能lock一个不存在的行。这个查询结果会跟普通的select是不同的。SELECT…FOR UPDATE总是不得不访问行数据进行lock，所以这种情况下索引是不会生效的，这样事务会很慢 select没有锁的字段是不会执行锁定的务必控制好锁定的时间，如果事务执行时间很长，会对系统有很大问题锁定需要的数据，无关的不要锁定缩减一个事务的处理粒度对整个表的影响（更改添加）越小越好使用SELECT…FOR UPDATE如果你想更新大部分你所选择的行外部锁sELECT GET_LOCK(‘mylock’)可以避免死锁 *********隔离级别********nnoDB支持很多种的隔离级别。这些隔离级别可以设置为全局有效 也可以针对每个连接和每个事务。 READ UMCOMMITED（不提交读）— 这个是很少使用。其他事务未提交的数据也可以读取到，会影响性能。 READCOMMITED（获取提交的数据）在执行过程中，可以读取到其他事务刚提交（commit）完毕的数据。在mysql5.1，InnoDB会有一些间歇锁在这个级别上。使用行级复制 和binlog可以避免这个问题。 REPEATABLE READ（可重复读）—默认的隔离级别。事务内的读都是完全可重复的，即事务只读取事务开始时候的数据状态，正在事务执行的时产生的数据不会出现。 SERIALIZABLE（串行化）&ndash;让所有select都锁住select，尽可能避免使用这个隔离级别。他会导致整个表只有一个select在执行，其他排队 ***********外键***********行更新的时候会检查外键，对性能有影响，现在很少人使用它了外键的更新会行锁定自己相关数据及其他表相关数据外键会锁住子表，当父表在更新的时候。（select … for update在父表上这样执行就不会锁住子表 ***********事务**********************在一定数量内的运行中的事务和执行查询，InnoDB性能表现良好多个运行中查询如果出现相互的性能干扰。通过配置Innodb_thread_concurrency能够控制同事在InnoDB内核中执行查询的线程数量。过多的事务运行会导致表内大量的锁，建议尽量减少锁在事务中的使用如果有可能，在同一时间内限制一定数量的查询，在应用程序端做好队列，这样能缓解服务器压力。处理量过多事务会超时回滚，在你调用的时候驱动要能够捕获这个错误 **********insert by select *****执行这个操作会导致select查询排队锁定直到他执行完毕强烈建议使用select into outfile或者load data infile不要直接这么查询 ***********间隙锁*************行锁的时候不仅仅锁定相关数据行，还会锁定两个行锁之间的数据，因为使用REPEATABLEREAD隔离模式的时候会出现重复数据。如果没有使用binlog，那么可以禁止这个间隙锁 *********关于count（*）*****innodb和myiasm如果count的时候有where条件的时候速度是一样的，如果没有条件那么myiasm速度最快innodb引擎变量内有一个表内数据总个数，但是这个数值不准innodb尽量避免使用大量数据的count*查询或者全表 *********推荐开发参考必看的经典***************http://7567567.blog.51cto.com/706378/586925 这个是下面的翻译，有很多不准确的地方，上面的介绍是我根据下面的的ppt再修正的http://www.mysqlperformanceblog.com/files/presentations/UC2007-Innodb-Performance-Optimization.pdf **********系统配置方面优化好文********************推荐文章地址：http://imysql.cn/node/609这个介绍的不错，讲了很多配置细节可以参考这个做数据库配置优化,并且有很多优化细节系列文章介绍","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/archives/173"},"@type":"BlogPosting","url":"http://localhost:4000/archives/173","headline":"【翻译整理】mysql innodb 的开发细节注意事项","dateModified":"2014-03-06T11:38:10+08:00","datePublished":"2014-03-06T11:38:10+08:00","author":{"@type":"Person","name":"徐艺洲"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="徐艺洲" /></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">徐艺洲</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/aboutme.html">关于我</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">【翻译整理】mysql innodb 的开发细节注意事项</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2014-03-06T11:38:10+08:00" itemprop="datePublished">Mar 6, 2014
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">徐艺洲</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div id="sina_keyword_ad_area2" class="articalContent   ">
  &#8212;资料整理线&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&lt;/p&gt; 
  
  <p>
    ************常规通用知识***************<br />innodb不支持全文索引<br />count（*）会扫表，变慢了<br />auto increament必须只有一个作为主键<br />innodb delete from table很慢，因为是一条条删除<br />innodb行锁是基与索引进行锁定的，如果要搞行锁的一定要注意<br />不要在innodb内做主键值更新<br />innodb 偏 insert update ，myiasm偏查询<br />innodb 多条update建议启用事务，否则容易卡慢超时<br />如果将自动提交关闭（SETAUTOCOMMIT= 0），那么innodb的性能会有显著提高，<br />但是开发过程中需要底层驱动自动执行提交事务操作否则对数据的更改添加的数据就会丢失<br />事务会超时，底层一定要做好捕获
  </p>
  
  <p>
    ********表的设计*******<br />innodb的主键是和数据一起存储的，所以当设计主键的时候可以考虑使用组合主键可以使得相同前缀的数据在一起<br />主键的无序随机存储会导致系统开销特别大，尽量通过主键排序，读取数据的时候尽量按照主键顺序读取会更快<br />，如果主键是auto incresement<br />不要更新主键开销特别大<br />主键要尽量的短因为其他索引是使用这个主键做索引的，这个会关系到索引的大小，如果索引过大，会导致查询缓慢
  </p>
  
  <p>
    没有主键的表查询会慢很多，但是这种情况他内部会创建 一个key ，不过查询的时候不好使用<br />如果一个表中有主键，同时所有查询都是通过主键进行，即使主键是比较长的，那通过主键进行查询也是更快的。<br />你可以给主键设置autoincreament并且加入唯一索引
  </p>
  
  <p>
    一个库内不要有太多的表<br />InnoDB自己的表定义（字典）缓存依赖于MySQL的table_cache变量值。只要打开一次，InnoDB就不会从缓存中移除这个表。<br />每张表大概要消耗4KB以上的空间。MySQL 5.1 的 InnoDB已经将这个空间减少了50% 到 75%，<br />当重启时，每个表的统计将会被重新计算。所以启动会是非常耗资源的。使用MySQL的插件table_cache将会串行执行这些操作。
  </p>
  
  <p>
    *********索引**********<br />使用唯一索引作为索引，查询速度会快很多<br />innodb的索引会比myiasm大很多，所以创建索引的时候要注意索引的大小，如果过大可能效果反倒不如没有索引<br />避免过多的索引<br />对所有需要更新时查询的列进行索引，如 DELETE FROM users WHEREname=’peter’如果name没有索引会锁定整个表<br />不要给自动增长字段设置值，否则在insert的时候会锁表，导致并发为1
  </p>
  
  <p>
    ********关于锁*********<br />当insert执行的时候拥有autoincrement（不在事务内）有几率锁表，会导致并发插入数据的时候的性能下降（这个问题据说在修5.5以后应该修了）<br />普通select不会锁表<br />只对需要的行进行锁定才会获得更好的性能，如果不能规划好解决事务间锁定冲突问题尽量不要使用锁，否则会导致卡住直到超时<br />共享锁的时候当产生更新到锁定数据的时候会禁止其他读锁访问<br />缓慢的select查询，不会影响表的update和查询操作<br />慢查询尽量避免，他会影响到数据一致性，如果使用 事务隔离级别read committed效果会好很多
  </p>
  
  <p>
    在readcommited模式下select会锁定。因为不能lock一个不存在的行。这个查询结果会跟普通的select是不同的。<br />SELECT…FOR UPDATE总是不得不访问行数据进行lock，所以这种情况下索引是不会生效的，这样事务会很慢
  </p>
  
  <p>
    select没有锁的字段是不会执行锁定的<br />务必控制好锁定的时间，如果事务执行时间很长，会对系统有很大问题<br />锁定需要的数据，无关的不要锁定<br />缩减一个事务的处理粒度对整个表的影响（更改添加）越小越好<br />使用SELECT…FOR UPDATE如果你想更新大部分你所选择的行<br />外部锁sELECT GET_LOCK(‘mylock’)可以避免死锁
  </p>
  
  <p>
    *********隔离级别********<br />nnoDB支持很多种的隔离级别。这些隔离级别可以设置为全局有效 也可以针对每个连接和每个事务。
  </p>
  
  <p>
    READ UMCOMMITED（不提交读）— 这个是很少使用。其他事务未提交的数据也可以读取到，会影响性能。
  </p>
  
  <p>
    READCOMMITED（获取提交的数据）在执行过程中，可以读取到其他事务刚提交（commit）完毕的数据。在mysql5.1，InnoDB会有一些间歇锁在这个级别上。<br />使用行级复制 和binlog可以避免这个问题。
  </p>
  
  <p>
    REPEATABLE READ（可重复读）—默认的隔离级别。事务内的读都是完全可重复的，即事务只读取事务开始时候的数据状态，正在事务执行的时产生的数据不会出现。
  </p>
  
  <p>
    SERIALIZABLE（串行化）&ndash;让所有select都锁住select，尽可能避免使用这个隔离级别。他会导致整个表只有一个select在执行，其他排队
  </p>
  
  <p>
    ***********外键***********<br />行更新的时候会检查外键，对性能有影响，现在很少人使用它了<br />外键的更新会行锁定自己相关数据及其他表相关数据<br />外键会锁住子表，当父表在更新的时候。（select … for update在父表上这样执行就不会锁住子表
  </p>
  
  <p>
    ***********事务**********************<br />在一定数量内的运行中的事务和执行查询，InnoDB性能表现良好<br />多个运行中查询如果出现相互的性能干扰。通过配置Innodb_thread_concurrency能够控制同事在InnoDB内核中执行查询的线程数量。<br />过多的事务运行会导致表内大量的锁，建议尽量减少锁在事务中的使用<br />如果有可能，在同一时间内限制一定数量的查询，在应用程序端做好队列，这样能缓解服务器压力。<br />处理量过多事务会超时回滚，在你调用的时候驱动要能够捕获这个错误
  </p>
  
  <p>
    **********insert by select *****<br />执行这个操作会导致select查询排队锁定直到他执行完毕<br />强烈建议使用select into outfile或者load data infile不要直接这么查询
  </p>
  
  <p>
    ***********间隙锁*************<br />行锁的时候不仅仅锁定相关数据行，还会锁定两个行锁之间的数据，因为使用REPEATABLEREAD隔离模式的时候会出现重复数据。<br />如果没有使用binlog，那么可以禁止这个间隙锁
  </p>
  
  <p>
    *********关于count（*）*****<br />innodb和myiasm如果count的时候有where条件的时候速度是一样的，如果没有条件那么myiasm速度最快<br />innodb引擎变量内有一个表内数据总个数，但是这个数值不准<br />innodb尽量避免使用大量数据的count*查询或者全表
  </p>
  
  <p>
    *********推荐开发参考必看的经典***************<br />http://7567567.blog.51cto.com/706378/586925 这个是下面的翻译，有很多不准确的地方，上面的介绍是我根据下面的的ppt再修正的<br />http://www.mysqlperformanceblog.com/files/presentations/UC2007-Innodb-Performance-Optimization.pdf
  </p>
  
  <p>
    **********系统配置方面优化好文********************<br />推荐文章地址：http://imysql.cn/node/609<br />这个介绍的不错，讲了很多配置细节可以参考这个做数据库配置优化,并且有很多优化细节系列文章介绍
  </p>
  
  <p>
  </p>
</div>

  </div><a class="u-url" href="/archives/173" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col one-half">
      <h2 class="footer-heading">徐艺洲</h2>
        <ul class="contact-list">
          <li class="p-name"></li></ul>
      </div>

      <div class="footer-col one-half">
        <p>知止定静安虑得</p>
      </div>

      <div class="social-links"><ul class="social-media-list"></ul>
</div>
    </div>

  </div>

</footer>
</body>

</html>
